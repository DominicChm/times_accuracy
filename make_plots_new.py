import numpy as np
import pickle
from Result import Result

from mpmath import gamma, pi, erf, exp, sqrt, quad, inf, mpf
from mpmath import npdf as phi
from mpmath import ncdf as Phi
from mpmath import mp

import matplotlib.pyplot as plt

reference_func = "cdf-mpgl"
data_file_path = "./data.p"
mp.dps = 30

results = pickle.load(open(data_file_path, "rb"))

# Step 1: Identify all present functions
function_names = set([res.fname for res in results])

if reference_func not in function_names:
    raise Exception(
        f"Selected reference function '{reference_func}' not found in data! Found {function_names}")

# Step 2: Identify the maximum precision in the reference function.
# Will warn if this is too small.
f_results = [r for r in results if r.fname == reference_func]
max_dop = max(f_results, key=lambda r: r.dop)

case_uids = set([r.case.uid for r in f_results])

# For each unique case...
for case_uid in case_uids:
    # Results that come from that case
    case_results = [r for r in results if r.case.uid == case_uid]

    # Names of functions that have a result for this case
    function_names = set([res.fname for res in case_results])

    plt.figure(figsize=(9, 6), dpi=250)

    for fname in function_names:
        x = [r.dop for r in case_results if r.fname == fname]
        y = [r.res for r in case_results if r.fname == fname]
        t = [r.dt for r in case_results if r.fname == fname]
        plt.semilogy(x, y, label="tests", marker='o', markersize=2, alpha=.7)
    plt.legend()

    plt.xticks(range(6, 26, 1))
    # plt.title(
    #     f'Magnitude Difference from \'mp-ts\'@{max_dop}: p={float(case_results[0].p):.10f} \n'
    #     f'q: {case_results[0].q}, k: {case_results[0].k}, nu: {case_results[0].v}, ')
    plt.ylabel('magnitude difference')
    plt.xlabel('degree of precision')
    # %%

    plt.savefig(f"images/q{case_uid}_DATA.png", dpi=250)
    plt.clf()
    plt.close()



        # Should have results for functions with same test case and dop, which are directly comparable.


for func_name in function_names:
    # The results generated by the current function name
    func_results = [r for r in results if r.fname == func_name]

    # Case UIDs found to have been evaled. by the current function name
    case_uids = set([res.case.uid for res in func_results])

    for case_uid in case_uids:
        # T his filter should leave the results that are different DOPs of
        # the selected case+function pair
        dop_results = [r for r in func_results if
                       r.fname == func_name and r.case.uid == case_uid]

# for key_comp in Fs['cdf_mp_ts']:
#     q, k, nu = key_comp.split("-")
#     print(key_comp)
#
#     gt = Fs["cdf_mp_ts"][key_comp][-1]
#     err = [np.abs([x - gt for x in np.ravel(Fs[key_name][key_comp])])
#            for key_name in Fs.keys()]
#
#     # make a plot for each calcualtion (DATA)
#     # %%
#
#     plt.figure(figsize=(9, 6), dpi=250)
#     plt.semilogy(*[x for y in zip([dpss] * len(err), err) for x in y],
#                  marker='o', markersize=2, alpha=.7)
#     legend_nice_label = [key[4:] for key in Fs.keys()]
#     plt.legend(legend_nice_label)
#     plt.xticks(range(6, 26, 1))
#     plt.title(
#         f'Magnitude Difference from \'mp-ts\'@{_max - 1}: p={float(gt):.10f} \n'
#         f'q: {q}, k: {k}, nu: {nu}, ')
#     plt.ylabel('magnitude difference')
#     plt.xlabel('degree of precision')
#     # %%
#
#     plt.savefig(f"images/q{str(q).strip('.')}-k{int(k)}-nu{int(nu)}_DATA.png",
#                 dpi=250)
#     plt.clf()
#     plt.close()
#
#     plt.figure(figsize=(9, 6), dpi=250)
#     times = [Ts[key_name][key_comp] for key_name in Ts.keys()]
#     plt.semilogy(*[x for y in zip([dpss] * len(err), times) for x in y],
#                  marker='o', markersize=2)
#     legend_nice_label = [key[4:] for key in Fs.keys()]
#     plt.legend(legend_nice_label)
#     plt.xticks(range(6, 26, 1))
#     plt.title(
#         f'Execution Time @ Degree Precision \'mp-ts\'@{_max - 1}: p={float(gt):.10f}\n'
#         f'q: {q}, k: {k}, nu: {nu}')
#     plt.ylabel('time (seconds)')
#     plt.xlabel('degree of precision')
#     plt.figtext(0.99, 0.01,
#                 '* `mp-ts`, `mp-gl`, and `dblquad` were run on a different system',
#                 horizontalalignment='right')
#     # %%
#
#     plt.savefig(f"images/q{str(q).strip('.')}-k{int(k)}-nu{int(nu)}_TIME.png",
#                 dpi=250)
#     plt.clf()
#     plt.close()

# for T_key in Ts.keys():
#     q, k, nu = T_key.split("-")
#     T = Ts[T_key]
#     # make plot for times
#     plt.semilogy(dpss, T["dblquad"], dpss, T["mp-ts"], dpss, T["ft"], dpss, T["dom"], dpss, T["psturng"])
#     plt.legend(("dblquad", "mp-ts", "Fortran", "C", "psturng"))
#     plt.title(f'Computation Time at Different Levels of Accuracy'
#               f'\nq: {q}, k: {k}, nu: {nu}')
#     plt.ylabel('time (seconds)')
#     plt.xlabel('degree of precision')
#     plt.savefig(f"images/q{str(q).strip('.')}-k{int(k)}-nu{int(nu)}_TIME.png", dpi=250)
#     plt.clf()
